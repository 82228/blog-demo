# Go语言中的内存逃逸
---
## 1. 来由
在C语言和C++这类需要手动管理内存的编程语言中，将对象或结构体分配到栈上或堆上是由工程师自主决定的，这带来了以下挑战：
1. **内存分配不当**：
   - 不需要分配到堆上的对象分配到了堆上 → 浪费内存空间
   - 需要分配到堆上的对象分配到了栈上 → 悬挂指针、影响内存安全
     在编译器优化中，**逃逸分析**是用来决定指针动态作用域的方法。Go语言的编译器使用逃逸分析决定哪些变量应该在栈上分配，哪些变量应该在堆上分配，以提高存储性能。
> 来源：Go语言的栈内存和逃逸分析 | Go语言设计与实现
---
## 2. 定义
**内存逃逸**：编译器将原本应该分配到栈上的变量，分配到了堆上（延长了变量的生命周期，在编译阶段完成）
### 内存分配位置
在Go语言中，程序在两个地方为变量分配内存：
1. **栈空间**：
   - 函数调用的参数、返回值以及小类型局部变量大都会被分配到栈上
   - 这部分内存由编译器管理，无需GC的标记
2. **堆空间**：
   - 全局变量、大对象、逃逸的变量会被分配到堆上
   - Go运行时GC会在后台标记这些内存，在垃圾回收时回收
   - 增加了GC开销
> 来源：Go语言的栈内存和逃逸分析 | Go语言设计与实现
---
## 3. 解决了什么问题
1. **减少堆内存的分配**
2. **降低空间的消耗**
3. **降低GC处理次数，减轻负担**
---
## 4. 产生情况
### 必然发生逃逸的四种情况
1. **指针逃逸**：在函数中通过new或字面量创建变量，将其指针作为函数返回值
2. **被逃逸变量引用**：被已经逃逸的变量引用的指针，一定发生逃逸
3. **容器引用**：被指针类型的slice、map和chan引用的指针一定发生逃逸
4. **闭包**：闭包引用的外部变量会逃逸
5. **栈空间不足**：当栈空间不足以容纳变量时
### 可能发生逃逸的情况
- 将指针作为参数传给别的函数，在被传入函数的处理过程中，如果发生了上述必然逃逸的情况，则会逃逸，否则不会
> 来源：https://zhuanlan.zhihu.com/p/91559562
---
## 5. 对应代码案例
### 5.1 指针逃逸
```go
func test() *int {
    a := 42       // 局部变量，分配在栈上
    return &a     // 返回局部变量的指针
}
```
**分析**：
1. `a`是局部变量，分配在栈上
2. 返回`a`的指针（指向栈内存）
3. 当`test`返回时，`a`的内存空间会被回收
4. 返回的指针将指向已释放的内存 → **指针悬挂问题**
5. Go编译器将`a`分配到堆上，确保返回的指针在函数返回后仍有效
### 5.2 被已经逃逸的变量引用的指针
```go
// 情况1：会发生逃逸
func test() {
    a := 42
    fmt.Println(&a)  // Println会逃逸指针
}
// 情况2：不会发生逃逸
func test() {
    a := 42
    p := &a
    fmt.Println(p)  // 直接打印指针值，不会逃逸
}
```
### 5.3 指针类型的slice、map和chan引用
```go
func test() {
    a := 42
    b := []int{a}      // 不会发生逃逸
    c := map[int]int{a: 1}  // 会发生逃逸
    d := make(chan *int)   // 会发生逃逸
    d <- &a
}
```
### 5.4 闭包
```go
func Increase() func() int {
    n := 0
    return func() int {
        n++
        return n
    }
}
```
**分析**：
- `Increase()`返回一个闭包函数
- 闭包函数访问外部变量`n`
- 变量`n`的生命周期延长，直到闭包被销毁
- `n`不能随着`Increase()`的退出而回收 → **逃逸到堆上**
### 5.5 栈空间不足
```go
// 不会发生逃逸：恰好64KB
func generate8192() []int {
    return make([]int, 8192)  // 8192*8=65536=64KB
}
// 会发生逃逸：超过64KB
func generate8193() []int {
    return make([]int, 8193)  // 8193*8>64KB
}
// 会发生逃逸：大小不确定
func generate(n int) []int {
    return make([]int, n)  // 编译时不确定大小
}
```
> 8192在64位系统中：int类型占用8字节，8192个整数占用65536字节=64KB（刚好在阈值范围内）
---
## 6. 影响
1. **栈分配优势**：
   - 在栈上分配和回收内存的开销很低，效率非常高
   - 消耗的时间仅是将数据拷贝到内存的时间
2. **堆分配劣势**：
   - 堆分配有额外的垃圾回收开销
   - 频繁内存逃逸会导致：
     - **内存占用增加**：延长变量生命周期，分配到堆上
     - **性能下降**：堆分配需要更多CPU和内存资源
     - **程序不稳定**：大量内存逃逸导致GC频繁工作
> 来源：王玉龙学长的博客
---
## 7. 利用逃逸分析提高性能
1. **指针传递的权衡**：
   - 传递指针可以减少底层值的复制，提高效率
   - 但小数据量时，指针传递可能产生逃逸，增加GC负担
   - **结论**：传递指针不一定是高效的
2. **参数传递建议**：
   - **传指针**：需要修改原对象值，或占用内存较大的结构体
   - **传值**：只读的占用内存较小的结构体
---
## 8. 有无替代品
### 手动管理内存
- 可以手动管理内存代替编译器自动管理
- 但Go语言的自动内存管理方案相对便捷，性能优势明显
### sync.Pool
- **问题**：栈内存用完即消，堆内存通过GC回收，增加内存分配开销
- **解决方案**：使用`sync.Pool`减少内存分配开销和回收压力
- **原理**：通过对象池复用内存，用完后清空池以便下次复用
> 来源：golang源码：src/sync/pool.go 和 src/sync/poolqueue.go
---
## 谢谢