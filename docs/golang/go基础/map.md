# Go 语言 map 详解

## 一、基本语法

### 1. 声明 map

（1）使用 make 函数声明

```
m := make(map[string]int)
```

（2）直接初始化声明

```
m := map[string]int{
    "name": 1,
    "age": 2,
    "sex": 3
}
```

### 2. 初始化带有预分配容量的 map

```
m := make(map[string]int, 10) // cap=10
```

### 3. 对 map 进行基本操作

#### （1）插入 / 修改

键存在为修改，不存在为插入

```
m["name"] = 4
m["address"] = 5
```

#### （2）删除键值对

```
delete(m, "name")
```

#### （3）查找元素并判断存在性

```
value, ok := m["name"]
if ok {
    fmt.Println("Value:", value)
} else {
    fmt.Println("Key does not exist")
}
```

#### （4）遍历 map

```
for key, value := range m {
    fmt.Printf("%s: %d\n", key, value)
}
```

## 二、map 底层实现

### 1. Go map 底层结构

#### 1. hmap 结构体

Go 中的 map 使用哈希表作为底层实现，其本质是一个指针（占用 8 个字节），指向 hmap 结构体。以下是 hmap 结构体的代码及注释（取自 Go 源码）：

```
type hmap struct {
    // count 表示当前map中活跃的键值对数量 = len(map)
    count int
    
    // 存储一些标志位，表示map的状态，例如是否正在扩容等等
    flags uint8
    
    // B 表示桶的数量的对数，桶的数量为2^B
    // 用于计算当前map的桶数组大小，初始值 B=0，表示初始桶有一个
    // 当map扩容时，B的值就会增加，0到1，1到2
    B uint8
    
    // 表示溢出桶的数量，数量过多时，会引发扩容操作
    // if 当前桶的对数B<16,则直接递增
    // 当>=16时，通过概率统计
    noverflow uint16
    
    // 哈希种子，是随机生成的值，用于增加随机性用于计算哈希值
    // 如果key为字符串，hashFunction则会根据字符串计算一个哈希值，如果是整数，则不用
    // 哈希值 = hashFunction("string") ^ hash0(哈希种子)
    // 假设B=3，则数量为8
    // 掩码为8-1=7
    // 则具体放入哪个桶可以用bucketIndex = 哈希值的二进制 & 掩码的二进制表示
    hash0 uint32
    
    // 指向当前桶数组的指针
    buckets unsafe.Pointer
    
    // 指向旧的桶数组，大小为当前桶数的一半
    oldbuckets unsafe.Pointer
    
    // 用于记录已经迁移的桶数，每次迁移完成后，值会更新
    nevacuate uintptr
    
    // 一个扩展结构，包含一些额外的字段。例如存储溢出桶的链表，键值的大小等等，了解即可
    extra *mapextra
}
```

其中 noverflow（溢出桶的个数）是通过下面的方法来计算的：

go

```
func (h *hmap) incrnoverflow() {
    // 当B(桶的对数）< 16时，noverflow是递增的
    if h.B < 16 {
        h.noverflow++
        return
    }
    // B>16时，是通过一种概率统计来计算的
    mask := uint32(1)<<(h.B-15) - 1
    if uint32(rand())&mask == 0 {
        h.noverflow++
    }
}
```

#### 2. bmap 结构体

hmap 结构体又包含若干个结构为 bmap 的数组，每个 bmap 底层都采用的是链表结构，bmap 通常又叫做 bucket。bmap 结构体如下所示：

```
type bmap struct {
    // 高八位，用于记录哈希值的最高8位
    tophash [bucketCnt]uint8
}
```

下面这个方法用来计算 tophash：

```
func tophash(hash uintptr) uint8 {
    // 是一个按位右移操作，用于提取哈希值的最高8位
    top := uint8(hash >> (goarch.PtrSize*8 - 8))
    // 确保顶级哈希值不小于 minTopHash（顶级哈希值的最小有效值）通常为5
    // 如果计算出的顶级哈希值 top 小于 minTopHash，则将其加上 minTopHash。
    // 这是为了确保顶级哈希值不会与桶的疏散状态冲突，疏散状态的值通常小于 minTopHash。
    if top < minTopHash {
        top += minTopHash
    }
    return top
}
```

上面方法是将一个完整的哈希值转换为一个 unit8 类型的顶级哈希值（tophash），存储在 bmap 中。

### 2. Go map 扩容机制

#### 1. 扩容规则 1：增量扩容

（1）条件：当负载因子 > 6.5 时（平均每个 bucket 存储的键值对达到 6.5 个），会触发增量扩容。

（2）扩容过程：当满足条件时，新建一个 bucket，新的 bucket 长度是原来的 2 倍，然后将旧 bucket 数据搬迁到新的 bucket。考虑到如果 map 存储了很多的 key-value，一次性搬迁将会造成比较大的延时，Go 采用逐步搬迁策略（渐进式扩容），即每次访问 map 时都会触发一次搬迁，每次搬迁 2 个键值对，等到旧的 bucket 中的数据全部搬迁完之后，释放旧的 bucket。

#### 2. 扩容规则 2：等量扩容

（1）条件：溢出桶太多。具体条件：

- 当总桶数 <2^15 时，如果溢出桶数量>= 总桶数，则认为溢出桶太多；
- 当总桶数 >= 2^15 时，如果溢出桶数量 >= 2^15，则认为溢出桶太多。

（2）扩容过程：所谓等量扩容，实际上并不是扩大容量，buckets 数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使 bucket 的使用率更高，进而保证更快的存取。在极端场景下，比如不断地增删，而键值对正好集中在一小部分的 bucket，这样会造成 overflow 的 bucket 数量增多，但负载因子又不高，从而无法执行增量搬迁的情况。经过重新组织后 overflow 的 bucket 数量会减少，既节省了空间又会提高访问效率。

### 3. 哈希冲突

通过哈希计算，如果两个哈希值通过计算得到的结果一样，即发生哈希冲突。Go map 采用拉链法解决哈希冲突：

1. **线性探测法**：当存储一个 key-value 时，发现 hash (key) 的下标已经被其他 key 占用，则在数组中顺着当前位置找下一个未被占用的位置存储冲突的 key。

   ​

2. **拉链法**：当 key 的 hash 冲突时，在冲突位置的元素上形成一个链表，通过指针互相连接。查找时，发现 key 冲突，顺着链表一直往下找，直到链表的尾节点，找不到则返回空。

   ​

### 4. 渐进式扩容（增量扩容中提到过）

1. **核心思想**：迁移数据的过程并不是一次性完成的，而是分多次逐步迁移。每当对 map 进行插入或删除操作时，运行时会顺便迁移一部分旧桶中的数据到新桶中。这样可以将扩容的性能开销分摊到多次操作中，而不是集中在某一次操作上。

   ​

2. **迁移过程**：
   （1）Go 的 hmap 结构体中维护了两个桶数组：一个旧的桶数组和一个新的桶数组。
   （2）在渐进式扩容期间，map 会同时使用旧桶和新桶进行数据存取。
   （3）每次操作时，map 会处理一个旧桶中的数据，将其迁移到新桶中，同时标记该旧桶为已迁移。
   （4）当所有旧桶的数据都迁移完成后，扩容结束，旧桶数组被释放。

   ​

## 三、总结

以上就是关于 Go map 的所有内容，如有没涉及到的或者是大家觉得不正确的地方，欢迎评论区留言或者私信作者。