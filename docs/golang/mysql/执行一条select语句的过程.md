- # 📚 MySQL 执行 SELECT 语句的完整流程详解

  ## 🔌 一、连接器（Connection Manager）

  ### 🔗 1.1 连接建立机制

  MySQL 支持两种连接模式，其核心区别在于 TCP 连接的生命周期：

  | **连接类型** | **默认方式**           | **TCP 连接生命周期**              | **适用场景**                 |
  | ------------ | ---------------------- | --------------------------------- | ---------------------------- |
  | **长连接**   | 需显式配置             | 建立一次连接，执行多次 SQL 后断开 | 应用程序持续访问数据库       |
  | **短连接**   | `mysql -u root -p`默认 | 执行单条 SQL 后立即断开连接       | 临时手动操作、脚本一次性任务 |

  **长连接流程**：

  1. 建立 TCP 连接（三次握手）
  2. 执行 SQL 语句①
  3. 执行 SQL 语句②
     ...
     n. 断开 TCP 连接（四次挥手）

  **短连接流程**：

  1. 建立 TCP 连接（三次握手）
  2. 执行单条 SQL 语句
  3. 断开 TCP 连接（四次挥手）

  ### 🔐 1.2 连接管理与身份认证

  - **连接池维护**：数据库通过`wait_timeout`（默认 8 小时）和`interactive_timeout`参数控制空闲连接回收

  - 身份校验流程

    ：

    1. 验证用户名密码（存储在`mysql.user`表中）
    2. 验证失败：返回`Access denied for user`错误并终止连接
    3. 验证成功：加载用户权限快照（后续权限变更需重新连接生效）

    ​

  ## 📦 二、查询缓存（Query Cache）

  > **注意**：MySQL 8.0 版本已完全移除查询缓存功能，以下流程仅适用于 MySQL 5.7 及更早版本

  ### 🗄️ 2.1 缓存工作机制

  plaintext

  ```
  客户端 → SQL请求 → 解析语句类型 → SELECT语句 → 检查缓存 → 缓存命中 → 返回结果
                                        ↓           ↓
                                    非SELECT      缓存未命中 → 执行后续流程 → 结果存入缓存
  ```

  ### ⚠️ 2.2 缓存特性与局限性

  - **存储结构**：以 SQL 语句为 KEY，查询结果为 VALUE 的内存哈希表
  - **失效机制**：关联表发生任何写操作（INSERT/UPDATE/DELETE）时，相关缓存立即失效
  - **适用场景**：只读表、低频更新表、相同 SQL 高重复执行场景
  - **性能陷阱**：高更新频率表会导致缓存频繁失效，反而增加 CPU 开销

  ## 🔍 三、SQL 解析（SQL Parsing）

  ### 🔤 3.1 词法分析（Lexical Analysis）

  - **核心功能**：将 SQL 字符串分解为语义单元（Tokens）

  - 示例过程

    ：

    sql

    ​

    ```
    SELECT id, name FROM user WHERE age > 18
    ```

    ​

    识别为：

    ```
    SELECT
    ```

    (关键字)、

    ```
    id
    ```

    (列名)、

    ```
    ,
    ```

    (分隔符)、

    ```
    name
    ```

    (列名)、

    ```
    FROM
    ```

    (关键字)、

    ```
    user
    ```

    (表名)、

    ```
    WHERE
    ```

    (关键字)、

    ```
    age
    ```

    (列名)、

    ```
    >
    ```

    (运算符)、

    ```
    18
    ```

    (常量)

  ### 🌳 3.2 语法分析（Syntactic Analysis）

  - **核心功能**：构建抽象语法树（AST），验证 SQL 语法合法性

  - 错误检测

    ：

    - 关键字拼写错误（如`SELEC * FROM user`）
    - 语法结构错误（如缺少`FROM`子句）
    - 表名 / 列名未定义（此阶段仅检查语法，不检查表是否存在）

    ​

  ## ▶️ 四、SQL 执行（SQL Execution）

  ### 🔧 4.1 预处理阶段（Preprocessing）

  - 语义校验

    ：

    - 检查表和列是否存在（查询`information_schema`）
    - 验证权限（如是否有`SELECT`权限）

    ​

  - 语句重写

    ：

    - 扩展`SELECT *`为具体列名
    - 处理别名（如`SELECT u.name AS username`）
    - 解析函数和表达式（如`NOW()`、`CONCAT()`）

    ​

  ### 📊 4.2 优化阶段（Optimization）

  - **优化器目标**：生成成本最低的执行计划（Cost-Based Optimization）

  - 关键优化策略

    ：

    - **索引选择**：在多个可用索引中选择代价最低的（如全表扫描 vs 索引扫描）
    - **连接顺序**：多表连接时调整表的访问顺序（小表驱动大表）
    - **条件简化**：如`WHERE id > 10 AND id < 20`简化为`id BETWEEN 11 AND 19`

    ​

  - **执行计划查看**：通过`EXPLAIN SELECT ...`命令可查看优化器决策结果

  ### 🚀 4.3 执行阶段（Execution）

  **主键索引查询示例**（`SELECT * FROM user WHERE id = 1`）：

  1. **执行器与存储引擎交互**：

     ​

     plaintext

     ​

     ​

     ```
     执行器 → 调用InnoDB接口 → 定位记录 → 返回结果 → 客户端
     ```

     ​

  2. **具体步骤**：

     ​

     - 调用`read_first_record`接口，传入条件`id = 1`
     - 存储引擎通过 B + 树索引定位到对应叶节点
     - 若记录存在：返回完整行数据；若不存在：返回 "记录不存在"
     - 执行器检查记录是否符合所有条件（如存在其他过滤条件）
     - 调用`read_record`接口准备下一条记录，因主键唯一返回 - 1，循环结束

     ​

  3. **非主键查询差异**：

     ​

     - 全表扫描：逐行检查条件，效率低（O (n)）
     - 非唯一索引：定位到索引叶节点后，需回表查询完整数据

     ​

  ## 📝 五、执行流程总结

  mermaid

  ```
  graph TD
      A[连接器] -->|建立连接/校验权限| B[查询缓存]
      B -->|命中| Z[返回结果]
      B -->|未命中| C[SQL解析]
      C -->|词法/语法分析| D[预处理]
      D -->|语义校验/重写| E[优化器]
      E -->|生成执行计划| F[执行器]
      F -->|调用存储引擎接口| G[返回结果]
      G --> Z
  ```

  ### 🌟 关键节点特性

  1. **权限检查**：仅在连接建立时加载一次，后续权限变更不影响现有连接
  2. **缓存策略**：8.0 版本移除，5.7 及以下建议关闭（`query_cache_type=0`）
  3. **执行计划**：优化器决策基于统计信息，定期执行`ANALYZE TABLE`可提升准确性
  4. **存储引擎接口**：执行器通过统一接口（Handler API）与不同存储引擎交互，实现插件化设计